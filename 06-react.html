<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSC13008-23KTPM1-06-React</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1460132164768330" crossorigin="anonymous"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Web Application Development</h1>
					<h2>CSC13008-23KTPM1</h2>
					<h3>Note 06 - React</h3>
					<p><small>Lecturer: <a href="mailto:dnkha@fit.hcmus.edu.vn">Đỗ Nguyên Kha</a></small></p>
					<p><small>Semester 1/2025-2026 @ FIT-HCMUS</small></p>
					<p><small><a href="?print-pdf">[Print]</a></small></p>
				</section>
				<section>
					<h3>Content</h3>
					<ol>
						<li>Virtual DOM</li>
						<li>Component</li>
						<li>JSX</li>
						<li><code>props</code></li>
						<li>Handling Events</li>
						<li>Hooks</li>
						<li><code>useState</code></li>
						<li><code>useEffect</code></li>
					</ol>
				</section>
				<section>
					<h3>Introduction to React</h3>
					<p>
						React’s declarative and component-based approach offers solutions to the challenges faced when using plain JavaScript
						for dynamic UIs.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const App = () => {
							const handleClick = () => {
								alert("Button Clicked!");
							};

							return (
								<div>
									<h1>Welcome to React</h1>
									<button onClick={handleClick}>Click Me</button>
								</div>
							);
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						The real DOM is the actual DOM tree that the browser renders and displays to the user. This means any
						changes made to the real DOM are immediately reflected on the user's screen, but direct manipulation can be
						inefficient
						for complex or frequent updates due to the performance cost of re-rendering the UI.
					</p>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>1. Initial real DOM</h4>
					<p>
						Examine the starting point of our application by viewing the initial HTML structure rendered in the browser. In this
						step, the initial real DOM rendered by the browser is created.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>2. Initial rendering and virtual DOM creation</h4>
					<p>
						In this step, React creates a virtual DOM that mirrors the initial real DOM.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const virtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>3. UI update triggered</h4>
					<p>
						Next, update the UI by adding a new header element:
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>4. Updated virtual DOM creation</h4>
					<p>
						In this step, React creates an updated virtual DOM that includes the new header element.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const updatedVirtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
								{
									type: 'h3',
									props: {},
									children: ['Element'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>5. Diffing the virtual DOMs</h4>
					<p>
						React now compares the initial and updated virtual DOMs to identify what has changed. React uses it's diffing algorithm
						to determine the differences between the two virtual DOMs by:
					</p>
					<ul>
						<li>Comparing each node in the initial and updated virtual DOMs.</li>
						<li>Identify any additions, deletions, or modifications.</li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>6. Identifying changes</h4>
					<p>
						After diffing, React determines the specific changes needed. It reviews the findings of the diffing process to see what
						updates are necessary.
					</p>
					<ul>
						<li>Unchanged nodes: <code>&lt;h1&gt;Hello&lt;/h1&gt;</code> and <code>&lt;h2&gt;React&lt;/h2&gt;</code></li>
						<li>New node detected: <code>&lt;h3&gt;Element&lt;/h3&gt;</code></li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>7. Updating the real DOM</h4>
					<p>
						React updates the real DOM by applying changes identified during the diffing process, inserting the new element (<code>&lt;h3&gt;Element&lt;/h3&gt;</code>) into the real DOM under the existing <code>&lt;div&gt;</code> element.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						<img src="./img/Browser-DOM-Virtual-DOM.webp">
					</p>
					<small>Source: <a
							href="https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/">https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/</a></small>
				</section>
				<section>
					<h3>JSX (JavaScript XML)</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic. It's an optional syntax extension for JavaScript that looks like
						HTML but is compiled into JavaScript. It allows us to write UI code in a way that’s intuitive and closer to how our UI
						will look in the browser.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = <h1>Hello, JSX!</h1>;
					</code></pre>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = React.createElement('h1', null, 'Hello, JSX!');
					</code></pre>
				</section>
				<section>
					<h3>Rendering lists in JSX</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const items = ['React', 'JSX', 'Components'];
						const elements = (
						<ul>
							{items.map((item) => (
							<li key={item}>{item}</li>
							))}
						</ul>
						);
						
						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(elements);
					</code></pre>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						The <code>createRoot</code> method takes one argument: <strong>Where to render</strong> - A DOM node in the HTML document where the React content will be displayed.
					</p>
					<p>
						Once the root container is created, the <code>render</code> method takes: <strong>What to render</strong> - A React element or JSX expression that describes the UI.
					</p>
					<p>
						Typically, React applications render their content inside a single HTML container, often an element with the ID <code>root</code>.
					</p>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						Even though React components are the preferred way to handle dynamic updates, we can manually call the <code>render</code> method
						multiple times to update content. Each call replaces content in the DOM node.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						let counter = 0;
						const root = ReactDOM.createRoot(document.getElementById('root'));

						function updateCounter() {
							root.render(<h1>Counter: {counter}</h1>);
						}

						// Initial render
						updateCounter();

						// Simulate updates
						setInterval(() => {
							counter++;
							updateCounter();
						}, 500);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Display current date and time dynamically</li>
					</ul>
				</section>
				<section>
					<h3>Component</h3>
					<p><img width="70%" src="./img/react-components.svg"></p>
				</section>
				<section>
					<h3>Component</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						// Greeting component
						function Greeting() {
							return <h1>Hello, World!</h1>;
						}

						// Footer component
						function Footer() {
							return <p>&copy; 2025 CSC13008-23KTPM1</p>;
						}

						// App
						function App() {
							return (
								<div>
									&lt;Greeting/&gt;
									&lt;Footer/&gt;
								</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3><code>StrictMode</code></h3>
					<p>React <code>StrictMode</code> is a development-only tool that helps identify potential problems and enforce best practices in React
					applications. It does not affect the UI or production build but enables additional checks and warnings to catch common
					bugs and improve code quality early.</p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><img src="./img/react-props.svg" width="75%"></p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><code>props</code> (short for “properties”) are a mechanism for passing data from a parent component to a child component. They allow
					components to be dynamic and reusable by enabling them to receive input data and render accordingly.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return <p>{props.text}</p>;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" /&gt;
								&lt;Message text="Welcome to React." /&gt;
								&lt;Message text="Props are awesome!" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Passing multiple <code>props</code></h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return &lt;p style={{ color: props.color }}&gt;{props.text}&lt;/p&gt;;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" color="red" /&gt;
								&lt;Message text="Welcome to React." color="green" /&gt;
								&lt;Message text="Props are awesome!" color="blue" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Create the <code>UserCard</code> component</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<p>In React, there are three ways to apply styles to our components:</p>
					<ul>
						<li>Using CSS stylesheets</li>
						<li>Inline styles</li>
						<li>CSS modules</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						&lt;div className="hello"&gt;Using CSS stylesheets &lt;/div&gt;
					</code></pre>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						const inlineStyle = {
							backgroundColor: '#282c34',
							padding: '20px',
							color: 'white',
							textAlign: 'center',
						};
						return (
						<div>
							<h1>Styling Component</h1>
							&lt;div style={inlineStyle}&gt;Inline styles&lt;/div&gt;
							&lt;div style={{ color: 'white' , fontSize: '18px' , backgroundColor: 'navy' , fontWeight: 'bold' }}&gt;Inline styles&lt;/div&gt;
						</div>
						);
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>React handles events similarly to how events are handled in regular HTML and JavaScript, but with some syntactical
					differences</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<button onclick="handleClick()">Click Me</button>
					</code></pre>
					<p>Use <code>camelCase</code> (e.g., <code>onClick</code>, <code>onChange</code>) and pass a function reference as the event handler, not a <code>string</code>.</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<ul>
						<li><code>onClick</code>: Triggered when an element is clicked.</li>
						<li><code>onChange</code>: Triggered when the value of an input element changes.</li>
						<li><code>onSubmit</code>: Triggered when a form is submitted.</li>
						<li><code>onMouseOver</code>: Triggered when the mouse pointer moves over an element.</li>
						<li><code>onFocus</code> / <code>onBlur</code>: Triggered when an element gains or loses focus.</li>
					</ul>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>To pass arguments to our event handlers, wrapping the event handler in an arrow
					function.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleClick(message) {
								alert(message);
							}

							return (
							<div>
								&lt;button onClick={() => handleClick('Button clicked!')}&gt;Click Me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Forms are integral to web applications. React simplifies handling form inputs and submissions.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleChange(event) {
								console.log('Input value:', event.target.value);
							}

							return (
							<div>
								&lt;input
									type="text"
									onChange={handleChange}         
									placeholder="Type something..."
								/&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Sometimes, we may need to prevent the default action of an event, such as preventing a form from submitting and
					refreshing the page.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleSubmit(event) {
								event.preventDefault();       
								alert('Form submitted!');
							}

							return (
							&lt;form onSubmit={handleSubmit}&gt;
								&lt;input type="text" placeholder="Enter your name" /&gt;
								<button type="submit">Submit</button>
							&lt;/form&gt;
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>We can pass event handlers to child components via props, promoting modularity and reusability.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Render TODO using React</li>
					</ul>
				</section>
				<section>
					<h3>Hooks</h3>
					<p>React hooks are special functions that let us use state and other React features without writing class components. The
					primary goal is to simplify how we manage data (state) and tasks like fetching data, updating the browser title, or
					running timers (effects) inside the UI components. By using hooks, our functional components can become more powerful
					while remaining concise and easy to read.</p>
				</section>
				<section>
					<h3>Hooks</h3>
					<p><img width="75%" src="./img/react-hooks.jpg" ></p>
					<small>Source: <a href="https://www.youtube.com/watch?v=LOH1l-MP_9k">https://www.youtube.com/watch?v=LOH1l-MP_9k</a></small>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p>By adding <code>useState</code>, the component now maintains its own data and reacts to user actions, transforming from a static,
					<em>“read-only”</em> UI into a dynamic, <em>“interactive”</em> one. All this is done without using class components.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function InteractiveGreeting() {
							const [message, setMessage] = React.useState("Hello, welcome to our React application!");
							
							function handleClick() {
								setMessage("Thanks for clicking, have a great day!");
							}
							
							return (
							<div>
								<h1>{message}</h1>
								&lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p><img width="75%" src="./img/react-use-state.webp"></p>
					<small>Source: <a
							href="https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/">https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/</a></small>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Click counter</li>
						<li>Toggle text visibility</li>
						<li>Real-time character counter for user input</li>
						<li>Change text color on button clicks</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The <code>useEffect</code> hook is used for performing side effects in our components. It runs after the component renders and can
					optionally re-run when specific values (called dependencies) change.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log(`Count updated: ${count}`);
						}, [count]); // 'count' is a dependency
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Dependencies are the values or state variables that, when changed, trigger the re-execution of the effect function
					provided to <code>useEffect</code>. These values are listed in an array as the second parameter of <code>useEffect</code>.</p>
					<p>Dependencies ensure that the useEffect logic is tied only to the values it depends on, avoiding unnecessary re-runs and
					optimizing performance. Incorrect dependencies or missing them altogether can lead to bugs like infinite loops or stale
					values.</p>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The empty dependency array (<code>[]</code>) ensures the effect runs only after the first render (on mount) and does not re-run
					during subsequent renders.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log("Component mounted");
						}, []);
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p><img width="50%" src="./img/react-use-effect.svg"></p>
					<small>Source: <a
							href="https://dmitripavlutin.com/react-useeffect-explanation/">https://dmitripavlutin.com/react-useeffect-explanation/</a></small>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Fetching data is one of the most common side effects in applications.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function UserList() {
							const [users, setUsers] = React.useState([]);
							const [loading, setLoading] = React.useState(true);
							
							React.useEffect(() => {
								fetch('https://jsonplaceholder.typicode.com/users')
								.then(response => response.json())
								.then(data => {
									setUsers(data);
									setLoading(false);
								});
							}, []);
							
							return (
							<div>
								{loading ? (
								<p>Loading...</p>
								) : (
								<ul>
									{users.map(user => (
									&lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
									))}
								</ul>
								)}
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Fetch and display a list of posts</li>
					</ul>
				</section>
				<section>
					<h3>Combining <code>useState</code> and <code>useEffect</code> for Dynamic Interactions</h3>
					<p>In real-world applications, components often need to manage their internal state and respond to external factors like
					user input, fetched data, or timers. By combining <code>useState</code> and <code>useEffect</code>, we can create fully interactive, dynamic
					components that manage both state and side effects seamlessly.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>We need to build a dynamic search component that allows users to type a query into an input field and see a filtered
						list of items in real time. Additionally, the items should be fetched dynamically when the component loads, simulating a
						common feature in modern applications like product or user searches.</li>
					</ul>
				</section>
				<section>
					<h3>Group Assignment - GA04</h3>
					<ul>
						<li>TODO app with React <code>useState</code> and <code>useEffect</code>: Add new task, Mark/Unmark as done, Remove task</li>
						<li>Scoring:
							<ul>
								<li>Tailwin and Responsive layout: 2.0</li>
								<li>Homepage, TODO list page (API): 2.0</li>
								<li>Add/Mark/Unmark/Remove (API): 6.0</li>
							</ul>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
