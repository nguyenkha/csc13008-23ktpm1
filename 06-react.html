<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSC13008-23KTPM1-06-React</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1460132164768330" crossorigin="anonymous"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Web Application Development</h1>
					<h2>CSC13008-23KTPM1</h2>
					<h3>Note 06 - React</h3>
					<p><small>Lecturer: <a href="mailto:dnkha@fit.hcmus.edu.vn">Đỗ Nguyên Kha</a></small></p>
					<p><small>Semester 1/2025-2026 @ FIT-HCMUS</small></p>
					<p><small><a href="?print-pdf">[Print]</a></small></p>
				</section>
				<section>
					<h3>Content</h3>
					<ol>
						<li>Virtual DOM</li>
						<li>Component</li>
						<li>JSX</li>
						<li><code>props</code></li>
						<li>Handling Events</li>
						<li>Hooks</li>
						<li><code>useState</code></li>
						<li><code>useEffect</code></li>
					</ol>
				</section>
				<section>
					<h3>Introduction to React</h3>
					<p>
						React’s declarative and component-based approach offers solutions to the challenges faced when using plain JavaScript
						for dynamic UIs.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const App = () => {
							const handleClick = () => {
								alert("Button Clicked!");
							};

							return (
								<div>
									<h1>Welcome to React</h1>
									<button onClick={handleClick}>Click Me</button>
								</div>
							);
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						The real DOM is the actual DOM tree that the browser renders and displays to the user. This means any
						changes made to the real DOM are immediately reflected on the user's screen, but direct manipulation can be
						inefficient
						for complex or frequent updates due to the performance cost of re-rendering the UI.
					</p>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>1. Initial real DOM</h4>
					<p>
						Examine the starting point of our application by viewing the initial HTML structure rendered in the browser. In this
						step, the initial real DOM rendered by the browser is created.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>2. Initial rendering and virtual DOM creation</h4>
					<p>
						In this step, React creates a virtual DOM that mirrors the initial real DOM.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const virtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>3. UI update triggered</h4>
					<p>
						Next, update the UI by adding a new header element:
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>4. Updated virtual DOM creation</h4>
					<p>
						In this step, React creates an updated virtual DOM that includes the new header element.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const updatedVirtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
								{
									type: 'h3',
									props: {},
									children: ['Element'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>5. Diffing the virtual DOMs</h4>
					<p>
						React now compares the initial and updated virtual DOMs to identify what has changed. React uses it's diffing algorithm
						to determine the differences between the two virtual DOMs by:
					</p>
					<ul>
						<li>Comparing each node in the initial and updated virtual DOMs.</li>
						<li>Identify any additions, deletions, or modifications.</li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>6. Identifying changes</h4>
					<p>
						After diffing, React determines the specific changes needed. It reviews the findings of the diffing process to see what
						updates are necessary.
					</p>
					<ul>
						<li>Unchanged nodes: <code>&lt;h1&gt;Hello&lt;/h1&gt;</code> and <code>&lt;h2&gt;React&lt;/h2&gt;</code></li>
						<li>New node detected: <code>&lt;h3&gt;Element&lt;/h3&gt;</code></li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>7. Updating the real DOM</h4>
					<p>
						React updates the real DOM by applying changes identified during the diffing process, inserting the new element (<code>&lt;h3&gt;Element&lt;/h3&gt;</code>) into the real DOM under the existing <code>&lt;div&gt;</code> element.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						<img src="./img/Browser-DOM-Virtual-DOM.webp">
					</p>
					<small>Source: <a
							href="https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/">https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/</a></small>
				</section>
				<section>
					<h3>JSX (JavaScript XML)</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic. It's an optional syntax extension for JavaScript that looks like
						HTML but is compiled into JavaScript. It allows us to write UI code in a way that’s intuitive and closer to how our UI
						will look in the browser.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = <h1>Hello, JSX!</h1>;
					</code></pre>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = React.createElement('h1', null, 'Hello, JSX!');
					</code></pre>
				</section>
				<section>
					<h3>Rendering lists in JSX</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const items = ['React', 'JSX', 'Components'];
						const elements = (
						<ul>
							{items.map((item) => (
							<li key={item}>{item}</li>
							))}
						</ul>
						);
						
						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(elements);
					</code></pre>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						The <code>createRoot</code> method takes one argument: <strong>Where to render</strong> - A DOM node in the HTML document where the React content will be displayed.
					</p>
					<p>
						Once the root container is created, the <code>render</code> method takes: <strong>What to render</strong> - A React element or JSX expression that describes the UI.
					</p>
					<p>
						Typically, React applications render their content inside a single HTML container, often an element with the ID <code>root</code>.
					</p>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						Even though React components are the preferred way to handle dynamic updates, we can manually call the <code>render</code> method
						multiple times to update content. Each call replaces content in the DOM node.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						let counter = 0;
						const root = ReactDOM.createRoot(document.getElementById('root'));

						function updateCounter() {
							root.render(<h1>Counter: {counter}</h1>);
						}

						// Initial render
						updateCounter();

						// Simulate updates
						setInterval(() => {
							counter++;
							updateCounter();
						}, 500);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Display current date and time dynamically</li>
					</ul>
				</section>
				<section>
					<h3>Component</h3>
					<p><img width="70%" src="./img/react-components.svg"></p>
				</section>
				<section>
					<h3>Component</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						// Greeting component
						function Greeting() {
							return <h1>Hello, World!</h1>;
						}

						// Footer component
						function Footer() {
							return <p>&copy; 2025 CSC13008-23KTPM1</p>;
						}

						// App
						function App() {
							return (
								<div>
									&lt;Greeting/&gt;
									&lt;Footer/&gt;
								</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3><code>StrictMode</code></h3>
					<p>React <code>StrictMode</code> is a development-only tool that helps identify potential problems and enforce best practices in React
					applications. It does not affect the UI or production build but enables additional checks and warnings to catch common
					bugs and improve code quality early.</p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><img src="./img/react-props.svg" width="75%"></p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><code>props</code> (short for “properties”) are a mechanism for passing data from a parent component to a child component. They allow
					components to be dynamic and reusable by enabling them to receive input data and render accordingly.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return <p>{props.text}</p>;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" /&gt;
								&lt;Message text="Welcome to React." /&gt;
								&lt;Message text="Props are awesome!" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Passing multiple <code>props</code></h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return &lt;p style={{ color: props.color }}&gt;{props.text}&lt;/p&gt;;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" color="red" /&gt;
								&lt;Message text="Welcome to React." color="green" /&gt;
								&lt;Message text="Props are awesome!" color="blue" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Create the <code>UserCard</code> component</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<p>In React, there are three ways to apply styles to our components:</p>
					<ul>
						<li>Using CSS stylesheets</li>
						<li>Inline styles</li>
						<li>CSS modules</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						&lt;div className="hello"&gt;Using CSS stylesheets &lt;/div&gt;
					</code></pre>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						const inlineStyle = {
							backgroundColor: '#282c34',
							padding: '20px',
							color: 'white',
							textAlign: 'center',
						};
						return (
						<div>
							<h1>Styling Component</h1>
							&lt;div style={inlineStyle}&gt;Inline styles&lt;/div&gt;
							&lt;div style={{ color: 'white' , fontSize: '18px' , backgroundColor: 'navy' , fontWeight: 'bold' }}&gt;Inline styles&lt;/div&gt;
						</div>
						);
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>React handles events similarly to how events are handled in regular HTML and JavaScript, but with some syntactical
					differences</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<button onclick="handleClick()">Click Me</button>
					</code></pre>
					<p>Use <code>camelCase</code> (e.g., <code>onClick</code>, <code>onChange</code>) and pass a function reference as the event handler, not a <code>string</code>.</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<ul>
						<li><code>onClick</code>: Triggered when an element is clicked.</li>
						<li><code>onChange</code>: Triggered when the value of an input element changes.</li>
						<li><code>onSubmit</code>: Triggered when a form is submitted.</li>
						<li><code>onMouseOver</code>: Triggered when the mouse pointer moves over an element.</li>
						<li><code>onFocus</code> / <code>onBlur</code>: Triggered when an element gains or loses focus.</li>
					</ul>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>To pass arguments to our event handlers, wrapping the event handler in an arrow
					function.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleClick(message) {
								alert(message);
							}

							return (
							<div>
								&lt;button onClick={() => handleClick('Button clicked!')}&gt;Click Me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Forms are integral to web applications. React simplifies handling form inputs and submissions.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleChange(event) {
								console.log('Input value:', event.target.value);
							}

							return (
							<div>
								&lt;input
									type="text"
									onChange={handleChange}         
									placeholder="Type something..."
								/&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Sometimes, we may need to prevent the default action of an event, such as preventing a form from submitting and
					refreshing the page.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleSubmit(event) {
								event.preventDefault();       
								alert('Form submitted!');
							}

							return (
							&lt;form onSubmit={handleSubmit}&gt;
								&lt;input type="text" placeholder="Enter your name" /&gt;
								<button type="submit">Submit</button>
							&lt;/form&gt;
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>We can pass event handlers to child components via props, promoting modularity and reusability.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Render TODO using React</li>
					</ul>
				</section>
				<section>
					<h3>Hooks</h3>
					<p>React hooks are special functions that let us use state and other React features without writing class components. The
					primary goal is to simplify how we manage data (state) and tasks like fetching data, updating the browser title, or
					running timers (effects) inside the UI components. By using hooks, our functional components can become more powerful
					while remaining concise and easy to read.</p>
				</section>
				<section>
					<h3>Hooks</h3>
					<p><img width="75%" src="./img/react-hooks.jpg" ></p>
					<small>Source: <a href="https://www.youtube.com/watch?v=LOH1l-MP_9k">https://www.youtube.com/watch?v=LOH1l-MP_9k</a></small>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p>By adding <code>useState</code>, the component now maintains its own data and reacts to user actions, transforming from a static,
					<em>“read-only”</em> UI into a dynamic, <em>“interactive”</em> one. All this is done without using class components.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function InteractiveGreeting() {
							const [message, setMessage] = React.useState("Hello, welcome to our React application!");
							
							function handleClick() {
								setMessage("Thanks for clicking, have a great day!");
							}
							
							return (
							<div>
								<h1>{message}</h1>
								&lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p><img width="75%" src="./img/react-use-state.webp"></p>
					<small>Source: <a
							href="https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/">https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/</a></small>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Click counter</li>
						<li>Toggle text visibility</li>
						<li>Real-time character counter for user input</li>
						<li>Change text color on button clicks</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The <code>useEffect</code> hook is used for performing side effects in our components. It runs after the component renders and can
					optionally re-run when specific values (called dependencies) change.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log(`Count updated: ${count}`);
						}, [count]); // 'count' is a dependency
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Dependencies are the values or state variables that, when changed, trigger the re-execution of the effect function
					provided to <code>useEffect</code>. These values are listed in an array as the second parameter of <code>useEffect</code>.</p>
					<p>Dependencies ensure that the useEffect logic is tied only to the values it depends on, avoiding unnecessary re-runs and
					optimizing performance. Incorrect dependencies or missing them altogether can lead to bugs like infinite loops or stale
					values.</p>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The empty dependency array (<code>[]</code>) ensures the effect runs only after the first render (on mount) and does not re-run
					during subsequent renders.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log("Component mounted");
						}, []);
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p><img width="50%" src="./img/react-use-effect.svg"></p>
					<small>Source: <a
							href="https://dmitripavlutin.com/react-useeffect-explanation/">https://dmitripavlutin.com/react-useeffect-explanation/</a></small>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Fetching data is one of the most common side effects in applications.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function UserList() {
							const [users, setUsers] = React.useState([]);
							const [loading, setLoading] = React.useState(true);
							
							React.useEffect(() => {
								fetch('https://jsonplaceholder.typicode.com/users')
								.then(response => response.json())
								.then(data => {
									setUsers(data);
									setLoading(false);
								});
							}, []);
							
							return (
							<div>
								{loading ? (
								<p>Loading...</p>
								) : (
								<ul>
									{users.map(user => (
									&lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
									))}
								</ul>
								)}
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Fetch and display a list of posts</li>
					</ul>
				</section>
				<section>
					<h3>Combining <code>useState</code> and <code>useEffect</code> for Dynamic Interactions</h3>
					<p>In real-world applications, components often need to manage their internal state and respond to external factors like
					user input, fetched data, or timers. By combining <code>useState</code> and <code>useEffect</code>, we can create fully interactive, dynamic
					components that manage both state and side effects seamlessly.</p>
				</section>
				<section>
					<h3>vite <code>/vit/</code></h3>
					<p>Vite  is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:</p>
					<ul>
						<li>A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module
						Replacement (HMR).</li>
						<li>A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for
						production.</li>
					</ul>
					<pre><code class="bash" style="word-wrap: break-word;" data-trim>
						npm create vite@latest
					</code></pre>
				</section>
				<section>
					<h3>TypeScript</h3>
					<p>TypeScript is JavaScript with syntax for types.</p>
					<ul>
						<li>Adds additional syntax to JavaScript to support a tighter integration with your editor..</li>
						<li>Converts to JavaScript, which runs anywhere JavaScript runs: In a browser, on Node.js, Deno, Bun and in
						your apps.</li>
						<li>Understands JavaScript and uses type inference to give you great tooling without additional code.</li>
					</ul>
					<pre><code class="typescript" style="word-wrap: break-word;" data-trim>
						interface User {
							name: string;
							id: number;
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>We need to build a dynamic search component that allows users to type a query into an input field and see a filtered
						list of items in real time. Additionally, the items should be fetched dynamically when the component loads, simulating a
						common feature in modern applications like product or user searches.</li>
					</ul>
				</section>
				<section>
					<h3>Group Assignment - GA04</h3>
					<ul>
						<li>TODO app with React <code>useState</code> and <code>useEffect</code>: Add new task, Mark/Unmark as done, Remove task</li>
						<li>Scoring:
							<ul>
								<li>Tailwind and Responsive layout: 2.0</li>
								<li>Homepage, TODO list page (API): 2.0</li>
								<li>Add/Mark/Unmark/Remove (API): 6.0</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>Prop drilling</h3>
					<p>Prop drilling is a situation in React where data (props) is passed from a parent component to deeply nested child
					components through intermediate components that don’t need the data.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function App() {
						const user = { name: 'John Doe', email: 'john@example.com' };

						return &lt;Parent user={user} /&gt;;
					}

					function Parent({ user }) {
						return &lt;Child user={user} /&gt;;
					}

					function Child({ user }) {
						return &lt;GrandChild user={user} /&gt;;
					}

					function GrandChild({ user }) {
						return <p>User Name: {user.name}</p>;
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>It allows us to create and provide data across components without prop drilling.
					It provides a way to pass data down the component tree without manually passing props at every level.</p>
					<img src="./img/react-use-context.png" width="50%">
					<small>Source: <a
							href="https://albertprofe.dev/reactjs/reactjs-hook-context.html">https://dmitripavlutin.com/react-useeffect-explanation/</a></small>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const UserContext = React.createContext();

					function App() {
						const user = { name: 'John Doe' };

						return (
							&lt;UserContext.Provider value={user}&gt;
								&lt;GrandChild /&gt;
							&lt;/UserContext.Provider&gt;
						);
					}

					function GrandChild() {
						const user = React.useContext(UserContext);
						return <p>User Name: {user.name}</p>;
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Let’s build a theming system where components dynamically adjust their styles (light or dark) based on a shared theme
					value. By using the useContext hook, we will efficiently share the theme across components without passing props
					manually.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					export const ThemeContext = createContext(); // Create a context
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Consuming context data with <code>useContext</code></p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function ThemedButton() {
						const theme = useContext(ThemeContext); // Access the current theme

						const buttonStyle = {
							backgroundColor: theme === 'dark' ? '#333' : '#fff',
							color: theme === 'dark' ? '#fff' : '#333',
							padding: '10px 20px',
							border: 'none',
							cursor: 'pointer',
						};

						const handleClick = () => {
							alert(`Button clicked in ${theme} mode`);
						};

						return &gt;button style={buttonStyle} onClick={handleClick}&lt;Click me&gt;/button&lt;;
					}

					export default ThemedButton;
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Once the context and the <code>ThemedButton</code> component are ready, we can provide the shared data (theme) to the <code>ThemedButton</code>
					using the <code>ThemeContext.Provider</code>.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function App() {
						const theme = 'dark'; // Current theme

						return (
							<ThemeContext.Provider value={theme}>
								<div>
									<h1>Welcome to the Themed App!</h1>
									<ThemedButton />
								</div>
							</ThemeContext.Provider>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Language toggle</li>
					</ul>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const [language, setLanguage] = useState('en'); // Current language
					// Manages the language state (en for English, vi for Vietnamese)
					const toggleLanguage = () =>
						setLanguage((prevLanguage) => (prevLanguage === 'en' ? 'vi' : 'en'));

					return (
					// Provides the language value to the LanguageContext.Provider
					&lt;LanguageContext.Provider value={language}&gt;
						<div>
							&lt;Greeting /&gt;
							&lt;button onClick={toggleLanguage}&gt;Toggle language&lt;/button&gt;
						</div>
					&lt;/LanguageContext.Provider&gt;
					);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Theme and language combined</li>
						<li>User authentication</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p>The <code>useRef</code> hook serves multiple purposes in managing data and interacting with the DOM. It provides a way to
					create a mutable reference, which can be used for two primary purposes:</p>
					<ul>
						<li>Accessing and manipulating DOM elements</li>
						<li>Storing persistent mutable values</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<ul>
						<li><strong>Mutable</strong>: The value stored in useRef can be updated directly via the current property.</li>
						<li><strong>Persistent across renders</strong>: Unlike variables declared inside a function, a <code>useRef</code> value is preserved between renders, making it suitable for
						managing non-UI data.</li>
						<li><strong>No re-render trigger</strong>: Modifying the <code>useRef</code> value does not affect the rendering cycle of the component.</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p><code>useRef</code> is commonly used to access and manipulate DOM elements directly.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function InputFocus() {
						const inputRef = React.useRef(null); // Create a ref object for the second input field

						// Handler for focusing the second input field using useRef
						const handleFocusWithRef = () => {
							inputRef.current.focus(); // Access and focus the input element
						};

						return (
							<div>
								<h3>With useRef</h3>
								<input ref={inputRef} type="text" placeholder="Enter text here" />
								&lt;button onClick={handleFocusWithRef}&gt;Focus input&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p><code>useRef</code> is also useful for storing mutable values that need to persist across renders but should not trigger a re-render
					when updated: a click counter or a timer.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function ClickCounter() {
						const countRef = React.useRef(0); // Mutable value
						const [renderCount, setRenderCount] = useState(0);

						const incrementCounter = () => {
							countRef.current += 1; // Increment the ref value
							console.log(`Clicks: ${countRef.current}`);
						};

						return (
							<div>
								<p>Rendered {renderCount} times</p>
								&lt;button onClick={incrementCounter}&gt;Increment counter&lt;/button&gt;
								&lt;button onClick={() => setRenderCount(renderCount + 1)}&gt;Re-render&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p>useRef can be used to persist the previous value of a state variable, making it useful for scenarios need to
					compare the current state with its previous value or perform calculations based on it.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function PreviousValue() {
						const [count, setCount] = React.useState(0);
						const prevCountRef = React.useRef();

						React.useEffect(() => {
							prevCountRef.current = count; // Update ref with the current state after rendering
						});

						return (
							<div>
								<p>Current count: {count}</p>
								<p>Previous count: {prevCountRef.current}</p>
								&lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Build a timer component that increments a counter every second using <code>useRef</code> to track elapsed time. The timer will have
					three buttons to control its behavior: Start, Pause, and Reset. You will use the <code>useRef</code> hook to efficiently track the
					timer's interval without causing unnecessary re-renders.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a page with multiple sections and a “Scroll to top” button. When clicked, this button will take the user back to
					the top of the page smoothly.</p>
				</section>
				<section>
					<h3>The <code>useMemo</code> hook</h3>
					<p>The <code>useMemo</code> hook is used to optimize the performance of our application by memoizing the result of a computation. It
					returns a memoized value that only recalculates when one of its dependencies changes. This avoids unnecessary
					recalculations on every render, making our application more efficient.</p>
				</section>
				<section>
					<h3>The <code>useMemo</code> hook</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const [count, setCount] = React.useState(0);
					// Memoizing the expensive computation
					const expensiveCalculation = React.useMemo(() => {
						console.log('Running expensive calculation...');
						return count * 1000;
					}, [count]);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a React component that filters a list of programming languages based on user input in a search box. Users will
					input a search term in the text box, and your code should dynamically filter and display only the programming languages
					that match the search term. Optimize the filtering logic using <code>useMemo</code>.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a React component to calculate fibonacci numbers. Users will input a number in the text box, and your code should
					compute and display the fibonacci number for that input using an optimized recursive function. Optimize the calculation
					using <code>useMemo</code>.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>You are tasked with creating an inventory management system that allows users to efficiently manage products and
					dynamically switch between light and dark themes. The system should include the following features:</p>
					<ul>
						<li><strong>Add products</strong>: name, quantity, and price</li>
						<li><strong>Search products</strong>: by name</li>
						<li><strong>Calculate total inventory value</strong>: total value of all products (<code>quantity* price</code>)</li>
						<li><strong>Theme toggle</strong>: light and dark themes</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
