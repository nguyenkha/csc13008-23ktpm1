<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSC13008-23KTPM1-06-React</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1460132164768330" crossorigin="anonymous"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Web Application Development</h1>
					<h2>CSC13008-23KTPM1</h2>
					<h3>Note 06 - React</h3>
					<p><small>Lecturer: <a href="mailto:dnkha@fit.hcmus.edu.vn">Đỗ Nguyên Kha</a></small></p>
					<p><small>Semester 1/2025-2026 @ FIT-HCMUS</small></p>
					<p><small><a href="?print-pdf">[Print]</a></small></p>
				</section>
				<section>
					<h3>Content</h3>
					<ol>
						<li>Virtual DOM</li>
						<li>Component</li>
						<li>JSX</li>
						<li><code>props</code></li>
						<li>Handling Events</li>
						<li>Hooks</li>
						<li><code>useState</code></li>
						<li><code>useEffect</code></li>
					</ol>
				</section>
				<section>
					<h3>Introduction to React</h3>
					<p>
						React’s declarative and component-based approach offers solutions to the challenges faced when using plain JavaScript
						for dynamic UIs.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const App = () => {
							const handleClick = () => {
								alert("Button Clicked!");
							};

							return (
								<div>
									<h1>Welcome to React</h1>
									<button onClick={handleClick}>Click Me</button>
								</div>
							);
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						The real DOM is the actual DOM tree that the browser renders and displays to the user. This means any
						changes made to the real DOM are immediately reflected on the user's screen, but direct manipulation can be
						inefficient
						for complex or frequent updates due to the performance cost of re-rendering the UI.
					</p>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>1. Initial real DOM</h4>
					<p>
						Examine the starting point of our application by viewing the initial HTML structure rendered in the browser. In this
						step, the initial real DOM rendered by the browser is created.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>2. Initial rendering and virtual DOM creation</h4>
					<p>
						In this step, React creates a virtual DOM that mirrors the initial real DOM.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const virtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>3. UI update triggered</h4>
					<p>
						Next, update the UI by adding a new header element:
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>4. Updated virtual DOM creation</h4>
					<p>
						In this step, React creates an updated virtual DOM that includes the new header element.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const updatedVirtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
								{
									type: 'h3',
									props: {},
									children: ['Element'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>5. Diffing the virtual DOMs</h4>
					<p>
						React now compares the initial and updated virtual DOMs to identify what has changed. React uses it's diffing algorithm
						to determine the differences between the two virtual DOMs by:
					</p>
					<ul>
						<li>Comparing each node in the initial and updated virtual DOMs.</li>
						<li>Identify any additions, deletions, or modifications.</li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>6. Identifying changes</h4>
					<p>
						After diffing, React determines the specific changes needed. It reviews the findings of the diffing process to see what
						updates are necessary.
					</p>
					<ul>
						<li>Unchanged nodes: <code>&lt;h1&gt;Hello&lt;/h1&gt;</code> and <code>&lt;h2&gt;React&lt;/h2&gt;</code></li>
						<li>New node detected: <code>&lt;h3&gt;Element&lt;/h3&gt;</code></li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>7. Updating the real DOM</h4>
					<p>
						React updates the real DOM by applying changes identified during the diffing process, inserting the new element (<code>&lt;h3&gt;Element&lt;/h3&gt;</code>) into the real DOM under the existing <code>&lt;div&gt;</code> element.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						<img src="./img/Browser-DOM-Virtual-DOM.webp">
					</p>
					<small>Source: <a
							href="https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/">https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/</a></small>
				</section>
				<section>
					<h3>JSX (JavaScript XML)</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic. It's an optional syntax extension for JavaScript that looks like
						HTML but is compiled into JavaScript. It allows us to write UI code in a way that’s intuitive and closer to how our UI
						will look in the browser.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = <h1>Hello, JSX!</h1>;
					</code></pre>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = React.createElement('h1', null, 'Hello, JSX!');
					</code></pre>
				</section>
				<section>
					<h3>Rendering lists in JSX</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const items = ['React', 'JSX', 'Components'];
						const elements = (
						<ul>
							{items.map((item) => (
							<li key={item}>{item}</li>
							))}
						</ul>
						);
						
						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(elements);
					</code></pre>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						The <code>createRoot</code> method takes one argument: <strong>Where to render</strong> - A DOM node in the HTML document where the React content will be displayed.
					</p>
					<p>
						Once the root container is created, the <code>render</code> method takes: <strong>What to render</strong> - A React element or JSX expression that describes the UI.
					</p>
					<p>
						Typically, React applications render their content inside a single HTML container, often an element with the ID <code>root</code>.
					</p>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						Even though React components are the preferred way to handle dynamic updates, we can manually call the <code>render</code> method
						multiple times to update content. Each call replaces content in the DOM node.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						let counter = 0;
						const root = ReactDOM.createRoot(document.getElementById('root'));

						function updateCounter() {
							root.render(<h1>Counter: {counter}</h1>);
						}

						// Initial render
						updateCounter();

						// Simulate updates
						setInterval(() => {
							counter++;
							updateCounter();
						}, 500);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Display current date and time dynamically</li>
					</ul>
				</section>
				<section>
					<h3>Component</h3>
					<p><img width="70%" src="./img/react-components.svg"></p>
				</section>
				<section>
					<h3>Component</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						// Greeting component
						function Greeting() {
							return <h1>Hello, World!</h1>;
						}

						// Footer component
						function Footer() {
							return <p>&copy; 2025 CSC13008-23KTPM1</p>;
						}

						// App
						function App() {
							return (
								<div>
									&lt;Greeting/&gt;
									&lt;Footer/&gt;
								</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3><code>StrictMode</code></h3>
					<p>React <code>StrictMode</code> is a development-only tool that helps identify potential problems and enforce best practices in React
					applications. It does not affect the UI or production build but enables additional checks and warnings to catch common
					bugs and improve code quality early.</p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><img src="./img/react-props.svg" width="75%"></p>
				</section>
				<section>
					<h3>Passing <code>props</code> to Components</h3>
					<p><code>props</code> (short for “properties”) are a mechanism for passing data from a parent component to a child component. They allow
					components to be dynamic and reusable by enabling them to receive input data and render accordingly.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return <p>{props.text}</p>;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" /&gt;
								&lt;Message text="Welcome to React." /&gt;
								&lt;Message text="Props are awesome!" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Passing multiple <code>props</code></h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function Message(props) {
							return &lt;p style={{ color: props.color }}&gt;{props.text}&lt;/p&gt;;
						}
						function App() {
							return (
							<div>
								&lt;Message text="Hello, World!" color="red" /&gt;
								&lt;Message text="Welcome to React." color="green" /&gt;
								&lt;Message text="Props are awesome!" color="blue" /&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Create the <code>UserCard</code> component</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<p>In React, there are three ways to apply styles to our components:</p>
					<ul>
						<li>Using CSS stylesheets</li>
						<li>Inline styles</li>
						<li>CSS modules</li>
					</ul>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						&lt;div className="hello"&gt;Using CSS stylesheets &lt;/div&gt;
					</code></pre>
				</section>
				<section>
					<h3>Styling Components</h3>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						const inlineStyle = {
							backgroundColor: '#282c34',
							padding: '20px',
							color: 'white',
							textAlign: 'center',
						};
						return (
						<div>
							<h1>Styling Component</h1>
							&lt;div style={inlineStyle}&gt;Inline styles&lt;/div&gt;
							&lt;div style={{ color: 'white' , fontSize: '18px' , backgroundColor: 'navy' , fontWeight: 'bold' }}&gt;Inline styles&lt;/div&gt;
						</div>
						);
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>React handles events similarly to how events are handled in regular HTML and JavaScript, but with some syntactical
					differences</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<button onclick="handleClick()">Click Me</button>
					</code></pre>
					<p>Use <code>camelCase</code> (e.g., <code>onClick</code>, <code>onChange</code>) and pass a function reference as the event handler, not a <code>string</code>.</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<ul>
						<li><code>onClick</code>: Triggered when an element is clicked.</li>
						<li><code>onChange</code>: Triggered when the value of an input element changes.</li>
						<li><code>onSubmit</code>: Triggered when a form is submitted.</li>
						<li><code>onMouseOver</code>: Triggered when the mouse pointer moves over an element.</li>
						<li><code>onFocus</code> / <code>onBlur</code>: Triggered when an element gains or loses focus.</li>
					</ul>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>To pass arguments to our event handlers, wrapping the event handler in an arrow
					function.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleClick(message) {
								alert(message);
							}

							return (
							<div>
								&lt;button onClick={() => handleClick('Button clicked!')}&gt;Click Me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Forms are integral to web applications. React simplifies handling form inputs and submissions.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleChange(event) {
								console.log('Input value:', event.target.value);
							}

							return (
							<div>
								&lt;input
									type="text"
									onChange={handleChange}         
									placeholder="Type something..."
								/&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>Sometimes, we may need to prevent the default action of an event, such as preventing a form from submitting and
					refreshing the page.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function App() {
							function handleSubmit(event) {
								event.preventDefault();       
								alert('Form submitted!');
							}

							return (
							&lt;form onSubmit={handleSubmit}&gt;
								&lt;input type="text" placeholder="Enter your name" /&gt;
								<button type="submit">Submit</button>
							&lt;/form&gt;
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Handling Events</h3>
					<p>We can pass event handlers to child components via props, promoting modularity and reusability.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Render TODO using React</li>
					</ul>
				</section>
				<section>
					<h3>Hooks</h3>
					<p>React hooks are special functions that let us use state and other React features without writing class components. The
					primary goal is to simplify how we manage data (state) and tasks like fetching data, updating the browser title, or
					running timers (effects) inside the UI components. By using hooks, our functional components can become more powerful
					while remaining concise and easy to read.</p>
				</section>
				<section>
					<h3>Hooks</h3>
					<p><img width="75%" src="./img/react-hooks.jpg" ></p>
					<small>Source: <a href="https://www.youtube.com/watch?v=LOH1l-MP_9k">https://www.youtube.com/watch?v=LOH1l-MP_9k</a></small>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p>By adding <code>useState</code>, the component now maintains its own data and reacts to user actions, transforming from a static,
					<em>“read-only”</em> UI into a dynamic, <em>“interactive”</em> one. All this is done without using class components.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function InteractiveGreeting() {
							const [message, setMessage] = React.useState("Hello, welcome to our React application!");
							
							function handleClick() {
								setMessage("Thanks for clicking, have a great day!");
							}
							
							return (
							<div>
								<h1>{message}</h1>
								&lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useState</code> hook</h3>
					<p><img width="75%" src="./img/react-use-state.webp"></p>
					<small>Source: <a
							href="https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/">https://www.kaashivinfotech.com/blog/usestate-in-react-js-guide-examples/</a></small>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Click counter</li>
						<li>Toggle text visibility</li>
						<li>Real-time character counter for user input</li>
						<li>Change text color on button clicks</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The <code>useEffect</code> hook is used for performing side effects in our components. It runs after the component renders and can
					optionally re-run when specific values (called dependencies) change.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log(`Count updated: ${count}`);
						}, [count]); // 'count' is a dependency
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Dependencies are the values or state variables that, when changed, trigger the re-execution of the effect function
					provided to <code>useEffect</code>. These values are listed in an array as the second parameter of <code>useEffect</code>.</p>
					<p>Dependencies ensure that the useEffect logic is tied only to the values it depends on, avoiding unnecessary re-runs and
					optimizing performance. Incorrect dependencies or missing them altogether can lead to bugs like infinite loops or stale
					values.</p>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>The empty dependency array (<code>[]</code>) ensures the effect runs only after the first render (on mount) and does not re-run
					during subsequent renders.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						React.useEffect(() => {
							console.log("Component mounted");
						}, []);
					</code></pre>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p><img width="50%" src="./img/react-use-effect.svg"></p>
					<small>Source: <a
							href="https://dmitripavlutin.com/react-useeffect-explanation/">https://dmitripavlutin.com/react-useeffect-explanation/</a></small>
				</section>
				<section>
					<h3>The <code>useEffect</code> hook</h3>
					<p>Fetching data is one of the most common side effects in applications.</p>
					<pre><code class="language-jsx" style="word-wrap: break-word;" data-trim>
						function UserList() {
							const [users, setUsers] = React.useState([]);
							const [loading, setLoading] = React.useState(true);
							
							React.useEffect(() => {
								fetch('https://jsonplaceholder.typicode.com/users')
								.then(response => response.json())
								.then(data => {
									setUsers(data);
									setLoading(false);
								});
							}, []);
							
							return (
							<div>
								{loading ? (
								<p>Loading...</p>
								) : (
								<ul>
									{users.map(user => (
									&lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
									))}
								</ul>
								)}
							</div>
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Fetch and display a list of posts</li>
					</ul>
				</section>
				<section>
					<h3>Combining <code>useState</code> and <code>useEffect</code> for Dynamic Interactions</h3>
					<p>In real-world applications, components often need to manage their internal state and respond to external factors like
					user input, fetched data, or timers. By combining <code>useState</code> and <code>useEffect</code>, we can create fully interactive, dynamic
					components that manage both state and side effects seamlessly.</p>
				</section>
				<section>
					<h3>vite <code>/vit/</code></h3>
					<p>Vite  is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:</p>
					<ul>
						<li>A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module
						Replacement (HMR).</li>
						<li>A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for
						production.</li>
					</ul>
					<pre><code class="bash" style="word-wrap: break-word;" data-trim>
						npm create vite@latest
					</code></pre>
				</section>
				<section>
					<h3>TypeScript</h3>
					<p>TypeScript is JavaScript with syntax for types.</p>
					<ul>
						<li>Adds additional syntax to JavaScript to support a tighter integration with your editor..</li>
						<li>Converts to JavaScript, which runs anywhere JavaScript runs: In a browser, on Node.js, Deno, Bun and in
						your apps.</li>
						<li>Understands JavaScript and uses type inference to give you great tooling without additional code.</li>
					</ul>
					<pre><code class="typescript" style="word-wrap: break-word;" data-trim>
						interface User {
							name: string;
							id: number;
						}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>We need to build a dynamic search component that allows users to type a query into an input field and see a filtered
						list of items in real time. Additionally, the items should be fetched dynamically when the component loads, simulating a
						common feature in modern applications like product or user searches.</li>
					</ul>
				</section>
				<section>
					<h3>Group Assignment - GA04</h3>
					<ul>
						<li>TODO app with React <code>useState</code> and <code>useEffect</code>: Add new task, Mark/Unmark as done, Remove task</li>
						<li>Scoring:
							<ul>
								<li>Tailwind and Responsive layout: 2.0</li>
								<li>Homepage, TODO list page (API): 2.0</li>
								<li>Add/Mark/Unmark/Remove (API): 6.0</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>Prop drilling</h3>
					<p>Prop drilling is a situation in React where data (props) is passed from a parent component to deeply nested child
					components through intermediate components that don’t need the data.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function App() {
						const user = { name: 'John Doe', email: 'john@example.com' };

						return &lt;Parent user={user} /&gt;;
					}

					function Parent({ user }) {
						return &lt;Child user={user} /&gt;;
					}

					function Child({ user }) {
						return &lt;GrandChild user={user} /&gt;;
					}

					function GrandChild({ user }) {
						return <p>User Name: {user.name}</p>;
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>It allows us to create and provide data across components without prop drilling.
					It provides a way to pass data down the component tree without manually passing props at every level.</p>
					<img src="./img/react-use-context.png" width="50%">
					<small>Source: <a
							href="https://albertprofe.dev/reactjs/reactjs-hook-context.html">https://dmitripavlutin.com/react-useeffect-explanation/</a></small>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const UserContext = React.createContext();

					function App() {
						const user = { name: 'John Doe' };

						return (
							&lt;UserContext.Provider value={user}&gt;
								&lt;GrandChild /&gt;
							&lt;/UserContext.Provider&gt;
						);
					}

					function GrandChild() {
						const user = React.useContext(UserContext);
						return <p>User Name: {user.name}</p>;
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Let’s build a theming system where components dynamically adjust their styles (light or dark) based on a shared theme
					value. By using the useContext hook, we will efficiently share the theme across components without passing props
					manually.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					export const ThemeContext = createContext(); // Create a context
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Consuming context data with <code>useContext</code></p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function ThemedButton() {
						const theme = useContext(ThemeContext); // Access the current theme

						const buttonStyle = {
							backgroundColor: theme === 'dark' ? '#333' : '#fff',
							color: theme === 'dark' ? '#fff' : '#333',
							padding: '10px 20px',
							border: 'none',
							cursor: 'pointer',
						};

						const handleClick = () => {
							alert(`Button clicked in ${theme} mode`);
						};

						return &gt;button style={buttonStyle} onClick={handleClick}&lt;Click me&gt;/button&lt;;
					}

					export default ThemedButton;
					</code></pre>
				</section>
				<section>
					<h3>The <code>useContext</code> hook</h3>
					<p>Once the context and the <code>ThemedButton</code> component are ready, we can provide the shared data (theme) to the <code>ThemedButton</code>
					using the <code>ThemeContext.Provider</code>.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function App() {
						const theme = 'dark'; // Current theme

						return (
							<ThemeContext.Provider value={theme}>
								<div>
									<h1>Welcome to the Themed App!</h1>
									<ThemedButton />
								</div>
							</ThemeContext.Provider>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Language toggle</li>
					</ul>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const [language, setLanguage] = useState('en'); // Current language
					// Manages the language state (en for English, vi for Vietnamese)
					const toggleLanguage = () =>
						setLanguage((prevLanguage) => (prevLanguage === 'en' ? 'vi' : 'en'));

					return (
					// Provides the language value to the LanguageContext.Provider
					&lt;LanguageContext.Provider value={language}&gt;
						<div>
							&lt;Greeting /&gt;
							&lt;button onClick={toggleLanguage}&gt;Toggle language&lt;/button&gt;
						</div>
					&lt;/LanguageContext.Provider&gt;
					);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Theme and language combined</li>
						<li>User authentication</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p>The <code>useRef</code> hook serves multiple purposes in managing data and interacting with the DOM. It provides a way to
					create a mutable reference, which can be used for two primary purposes:</p>
					<ul>
						<li>Accessing and manipulating DOM elements</li>
						<li>Storing persistent mutable values</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<ul>
						<li><strong>Mutable</strong>: The value stored in useRef can be updated directly via the current property.</li>
						<li><strong>Persistent across renders</strong>: Unlike variables declared inside a function, a <code>useRef</code> value is preserved between renders, making it suitable for
						managing non-UI data.</li>
						<li><strong>No re-render trigger</strong>: Modifying the <code>useRef</code> value does not affect the rendering cycle of the component.</li>
					</ul>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p><code>useRef</code> is commonly used to access and manipulate DOM elements directly.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function InputFocus() {
						const inputRef = React.useRef(null); // Create a ref object for the second input field

						// Handler for focusing the second input field using useRef
						const handleFocusWithRef = () => {
							inputRef.current.focus(); // Access and focus the input element
						};

						return (
							<div>
								<h3>With useRef</h3>
								<input ref={inputRef} type="text" placeholder="Enter text here" />
								&lt;button onClick={handleFocusWithRef}&gt;Focus input&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p><code>useRef</code> is also useful for storing mutable values that need to persist across renders but should not trigger a re-render
					when updated: a click counter or a timer.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function ClickCounter() {
						const countRef = React.useRef(0); // Mutable value
						const [renderCount, setRenderCount] = useState(0);

						const incrementCounter = () => {
							countRef.current += 1; // Increment the ref value
							console.log(`Clicks: ${countRef.current}`);
						};

						return (
							<div>
								<p>Rendered {renderCount} times</p>
								&lt;button onClick={incrementCounter}&gt;Increment counter&lt;/button&gt;
								&lt;button onClick={() => setRenderCount(renderCount + 1)}&gt;Re-render&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>The <code>useRef</code> hook</h3>
					<p>useRef can be used to persist the previous value of a state variable, making it useful for scenarios need to
					compare the current state with its previous value or perform calculations based on it.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					function PreviousValue() {
						const [count, setCount] = React.useState(0);
						const prevCountRef = React.useRef();

						React.useEffect(() => {
							prevCountRef.current = count; // Update ref with the current state after rendering
						});

						return (
							<div>
								<p>Current count: {count}</p>
								<p>Previous count: {prevCountRef.current}</p>
								&lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
							</div>
						);
					}
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Build a timer component that increments a counter every second using <code>useRef</code> to track elapsed time. The timer will have
					three buttons to control its behavior: Start, Pause, and Reset. You will use the <code>useRef</code> hook to efficiently track the
					timer's interval without causing unnecessary re-renders.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a page with multiple sections and a “Scroll to top” button. When clicked, this button will take the user back to
					the top of the page smoothly.</p>
				</section>
				<section>
					<h3>The <code>useMemo</code> hook</h3>
					<p>The <code>useMemo</code> hook is used to optimize the performance of our application by memoizing the result of a computation. It
					returns a memoized value that only recalculates when one of its dependencies changes. This avoids unnecessary
					recalculations on every render, making our application more efficient.</p>
				</section>
				<section>
					<h3>The <code>useMemo</code> hook</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const [count, setCount] = React.useState(0);
					// Memoizing the expensive computation
					const expensiveCalculation = React.useMemo(() => {
						console.log('Running expensive calculation...');
						return count * 1000;
					}, [count]);
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a React component that filters a list of programming languages based on user input in a search box. Users will
					input a search term in the text box, and your code should dynamically filter and display only the programming languages
					that match the search term. Optimize the filtering logic using <code>useMemo</code>.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>Create a React component to calculate fibonacci numbers. Users will input a number in the text box, and your code should
					compute and display the fibonacci number for that input using an optimized recursive function. Optimize the calculation
					using <code>useMemo</code>.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>You are tasked with creating an inventory management system that allows users to efficiently manage products and
					dynamically switch between light and dark themes. The system should include the following features:</p>
					<ul>
						<li><strong>Add products</strong>: name, quantity, and price</li>
						<li><strong>Search products</strong>: by name</li>
						<li><strong>Calculate total inventory value</strong>: total value of all products (<code>quantity* price</code>)</li>
						<li><strong>Theme toggle</strong>: light and dark themes</li>
					</ul>
				</section>
				<section>
					<h3>React Hook Form</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					npm install react-hook-form
					</code></pre>
				</section>
				<section>
					<h3>Group Assignment - GA05</h3>
					<ul>
						<li>Enhanched Shipping Form </li>
						<li>Scoring:
							<ul>
								<li>Tailwind and Responsive layout: 2.0</li>
								<li>Hooked Form: 2.0</li>
								<li>Populate Province/Ward List: 4.0</li>
								<li>Form Validation: 2.0</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>Router</h3>
					<p>React applications often require navigation between different pages or views, such as “Home,” “About,” “Projects,” or
					“Contact” pages. Traditionally, this is done by manually managing state or creating multiple HTML files.</p>
				</section>
				<section>
					<h3>A portfolio application</h3>
					<p>We need to build a portfolio website with the following pages:</p>
					<ul>
						<li>Home: A welcome page.</li>
						<li>About: Information about the individual.</li>
						<li>Projects: A showcase of completed projects.</li>
						<li>Contact: A page to get in touch.</li>
					</ul>
				</section>
				<section>
					<h3>A portfolio application</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					const App = () => {
						const [currentPage, setCurrentPage] = React.useState('Home');

						const renderPage = () => {
							switch (currentPage) {
								case 'Home':
									return <h1>Welcome to my portfolio</h1>;
								case 'About':
									return <h1>About me</h1>;
								case 'Projects':
									return <h1>My projects</h1>;
								case 'Contact':
									return <h1>Contact me</h1>;
								default:
									return <h1>404 page not found</h1>;
							}
						};

						return (
							<div>
								<nav>
									&lt;button onClick={() => setCurrentPage('Home')}&gt;Home&lt;/button&gt;
									&lt;button onClick={() => setCurrentPage('About')}&gt;About&lt;/button&gt;
									&lt;button onClick={() => setCurrentPage('Projects')}&gt;Projects&lt;/button&gt;
									&lt;button onClick={() => setCurrentPage('Contact')}&gt;Contact&lt;/button&gt;
								</nav>
								{renderPage()}
							</div>
						);
					}; 
					</code></pre>
				</section>
				<section>
					<h3>A portfolio application</h3>
					<p>Limitations of manual navigation:</p>
					<ul>
						<li><strong>No URLs for pages</strong>: The application does not use unique URLs for each page, making it impossible to bookmark or share links.</li>
						<li><strong>Poor user experience</strong>: Refreshing the browser resets the app to the default state (Home page).</li>
						<li><strong>Manual management</strong>: Adding new pages requires updating the renderPage function and navigation bar manually.</li>
						<li><strong>SEO issues</strong>: Search engines cannot crawl individual pages due to the lack of URLs.</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>React Router is the de-facto standard for handling routing in React applications. It allows developers to define routes,
					navigate between views, and manage URL parameters efficiently. With its robust features and integration capabilities,
					React Router is essential for building modern single-page applications (SPA).</p>
				</section>
				<section>
					<h3>Single-page applications (SPA)</h3>
					<p>A single-page application (SPA) is a web application that dynamically loads and updates content on a single HTML page.
					Instead of fetching a new HTML file for each route, SPAs render content dynamically based on the URL. This improves
					performance and creates a smoother user experience.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';

					const Home = () => <h1>Welcome to my portfolio</h1>;
					const About = () => <h1>About me</h1>;
					const Projects = () => <h1>My projects</h1>;
					const Contact = () => <h1>Contact me</h1>;

					const App = () => (
						&lt;Router&gt;
							<nav>
								&lt;Link to="/" className="link"&gt;Home&lt;/Link&gt;
								&lt;Link to="/about" className="link"&gt;About&lt;/Link&gt;
								&lt;Link to="/projects" className="link"&gt;Projects&lt;/Link&gt;
								&lt;Link to="/contact" className="link"&gt;Contact&lt;/Link&gt;
							</nav>
							&lt;Routes&gt;
								&lt;Route path="/" element={<Home />} /&gt;
								&lt;Route path="/about" element={<About />} /&gt;
								&lt;Route path="/projects" element={<Projects />} /&gt;
								&lt;Route path="/contact" element={<Contact />} /&gt;
							&lt;/Routes&gt;
						&lt;/Router&gt;
					);

					export default App
					</code></pre>
				</section>
				<section>
					<h3>React Router</h3>
					<ul>
						<li><strong>Seamless navigation</strong>: No full-page reloads; transitions between views are smooth and fast.</li>
						<li><strong>URL-based routing</strong>: Each route has a unique URL, making it easier to bookmark and share links.</li>
						<li><strong>Dynamic and scalable</strong>: Adding new routes is as simple as defining a new Route component.</li>
						<li><strong>Improved SEO</strong>: SPAs with React Router can be optimized for SEO using server-side rendering or pre-rendering tools.</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<ul>
						<li>Manual navigation is a quick and straightforward approach for small applications but is not scalable or efficient for larger projects.</li>
						<li>React Router introduces robust navigation and routing features essential for building modern, scalable, and user-friendly SPAs.</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>Routing is a fundamental feature of single-page React applications that emulate multi-page behavior. It enables
					developers to map specific URLs to components, allowing for dynamic view rendering and smooth, seamless navigation
					without full-page reloads.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>The <code>Route</code> component is used to map a specific URL path to a React component. The <code>path</code> property specifies the URL, and
					the <code>element</code> property determines which component to render when the path matches.</p>
					<p>The <code>Routes</code> component acts as a container for multiple <code>Route</code> definitions, ensuring only one matching route is rendered at
					a time.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Add a new route for a <strong>Services</strong> page to the application.</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>Create a <code>404</code> page: Add a wildcard route (<code>*</code>) to render a 404 page for undefined paths.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
					import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';

					const Home = () => <h1>Welcome to my portfolio</h1>;
					const About = () => <h1>About me</h1>;
					const Projects = () => <h1>My projects</h1>;
					const Contact = () => <h1>Contact me</h1>;
					const NotFound = () => <h1>404 page not found</h1>;

					const App = () => (
						&lt;Router&gt;
							<nav>
								&lt;Link to="/" className="link"&gt;Home&lt;/Link&gt;
								&lt;Link to="/about" className="link"&gt;About&lt;/Link&gt;
								&lt;Link to="/projects" className="link"&gt;Projects&lt;/Link&gt;
								&lt;Link to="/contact" className="link"&gt;Contact&lt;/Link&gt;
							</nav>
							&lt;Routes&gt;
								&lt;Route path="/" element={&lt;Home /&gt;} /&gt;
								&lt;Route path="/about" element={&lt;About /&gt;} /&gt;
								&lt;Route path="/projects" element={&lt;Projects /&gt;} /&gt;
								&lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
								{/* A wildcard route (*) to catch all undefined paths */}
								&lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
							&lt;/Routes&gt;
						&lt;/Router&gt;
					);

					export default App
					</code></pre>
				</section>
				<section>
					<h3>React Router</h3>
					<p>In traditional HTML, navigation is handled using &lt;a&gt; tags. However, &lt;a&gt; tags cause the browser to perform a full-page reload, which:</p>
					<ul>
						<li>Slows down navigation.</li>
						<li>Breaks the seamless user experience expected from SPAs.</li>
						<li>Clears the application state.</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>React Router provides components like <code>Link</code> and <code>NavLink</code> to enable smooth, single-page navigation without full-page
					reloads.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>The <code>Link</code> component is used to navigate between routes in a React application. It replaces traditional &lt;a&gt; tags for
						internal navigation while maintaining the SPA experience.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>While the <code>Link</code> component is great for basic navigation, it doesn’t provide a way to highlight the currently active
					route. This is where the <code>NavLink</code> component comes in. It works like <code>Link</code> but includes built-in functionality to detect
					the active route and apply specific styles or classes.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<ul>
						<li><strong>Active detection</strong>: The <code>NavLink</code> component automatically detects whether the current URL matches the to path and provides an <code>isActive</code> property.</li>
						<li><strong>Dynamic styling</strong>: Use the <code>isActive</code> property to apply styles or classes dynamically to the active link.</li>
					</ul>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Add a <code>Services</code> page to the application and include it in the navigation bar using NavLink. Highlight the active page
						when navigating.</li>
						<li>Add a footer to the application with navigation links for Home, About, and Contact. Use <code>Link</code> components for the footer
						links. The footer should display navigation links similar to the navigation bar.</li>
						<li>Add custom classes for active links</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>In many real-world applications, URLs often contain dynamic data. For example, a product page URL in an online store
					might look like <code>/products/123</code>, where <code>123</code> is the product ID that changes for each product available in the store.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>In React applications, such scenarios are handled through dynamic routing by defining routes with parameters. Dynamic
					routing enables us to define routes with placeholders for parameters, allowing URLs to include dynamic values. React
					Router supports dynamic routing by using a colon (:) in the route path to represent a parameter. For example:</p>
					<pre><code>&lt;Route path="/products/:id" element={&lt;ProductDetail /&gt;} /&gt;</code></pre>
				</section>
				<section>
					<h3>React Router</h3>
					<p>The <code>useParams</code> hook, provided by React Router, allows us to extract parameters from the current URL.</p>
					<pre><code>const params = useParams();</code></pre>
					<p>It returns an object containing all the dynamic parameters defined in the route as key-value pairs. For example, if the
					URL is <code>/products/123</code> and the route is defined as <code>/products/:id</code>, the object returned by <code>useParams()</code> will look like this:</p>
					<pre><code>{ id: "123" }</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Add a user profile page</li>
						<li>Create a blog post page</li>
						<li>Update the products page</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>As applications become more complex and feature-rich, organizing routes in a clear and maintainable way becomes
					critical. Often, we’ll find that certain sections of an application are logically grouped under a parent route. A great
					example of this is a "Dashboard" in a web application. Dashboards typically consist of multiple related subsections,
					such as "Profile", "Settings", and "Notifications", which all fall under the umbrella of the main Dashboard page.</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>Instead of defining each of these subsections as standalone routes, nested routes allow us to organize them under a
					single parent route like <code>/dashboard</code>. This parent-child route structure is useful for applications where some pages or
					sections have their own sub-pages. With nested routes, we can build scalable, modular applications while maintaining a
					consistent user experience.
					</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>A <code>404</code> page provides a user-friendly way to inform visitors that the requested page cannot be found. It often includes
					helpful navigation options, such as links to the Home page or a search feature, guiding users back to valid content.
					</p>
					<p>React Router allows us to define a wildcard route (<code>path="*"</code>) to handle any undefined paths in our application. Wildcard
					routes are typically used to display 404 pages.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Create a blog post page</li>
						<li>Update the products page</li>
					</ul>
				</section>
				<section>
					<h3>React Router</h3>
					<p>React Router offers the <code>useNavigate</code> hook to handle programmatic navigations. The useNavigate hook provides a function
					that allows us navigate to any route in our application programmatically, without relying on predefined links.</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const navigate = useNavigate();
						navigate('/path', { replace: true });
					</code></pre>
				</section>
				<section>
					<h3>Exercise</h3>
					<p>
						Redirecting users after completing a form, such as navigating to a dashboard after signup or login, is a common
						requirement in modern applications. The following code demonstrates a simple signup flow where users enter their email
						address to proceed. If an email is provided, the user is redirected to the profile page using the <code>useNavigate</code> hook;
						otherwise, an alert prompts them to enter an email.
					</p>
				</section>
				<section>
					<h3>React Router</h3>
					<p>Programmatically navigating to the previous page can improve user experience in scenarios like returning from a details
					page.</p>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Add a logout button</li>
					</ul>
				</section>
				<section>
					<h3>Exercise</h3>
					<ul>
						<li>Add product detail page</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
