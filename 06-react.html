<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSC13008-23KTPM1-06-React</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1460132164768330" crossorigin="anonymous"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Web Application Development</h1>
					<h2>CSC13008-23KTPM1</h2>
					<h3>Note 06 - React</h3>
					<p><small>Lecturer: <a href="mailto:dnkha@fit.hcmus.edu.vn">Đỗ Nguyên Kha</a></small></p>
					<p><small>Semester 1/2025-2026 @ FIT-HCMUS</small></p>
					<p><small><a href="?print-pdf">[Print]</a></small></p>
				</section>
				<section>
					<h3>Content</h3>
					<ol>
						<li>Virtual DOM</li>
						<li>Component</li>
						<li>JSX</li>
						<li><code>props</code></li>
						<li>Handling Events</li>
						<li>Hooks</li>
						<li><code>useState</code></li>
						<li><code>useEffect</code></li>
					</ol>
				</section>
				<section>
					<h3>Introduction to React</h3>
					<p>
						React’s declarative and component-based approach offers solutions to the challenges faced when using plain JavaScript
						for dynamic UIs.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const App = () => {
							const handleClick = () => {
								alert("Button Clicked!");
							};

							return (
								<div>
									<h1>Welcome to React</h1>
									<button onClick={handleClick}>Click Me</button>
								</div>
							);
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						The real DOM is the actual DOM tree that the browser renders and displays to the user. This means any
						changes made to the real DOM are immediately reflected on the user's screen, but direct manipulation can be
						inefficient
						for complex or frequent updates due to the performance cost of re-rendering the UI.
					</p>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>1. Initial real DOM</h4>
					<p>
						Examine the starting point of our application by viewing the initial HTML structure rendered in the browser. In this
						step, the initial real DOM rendered by the browser is created.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>2. Initial rendering and virtual DOM creation</h4>
					<p>
						In this step, React creates a virtual DOM that mirrors the initial real DOM.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const virtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>3. UI update triggered</h4>
					<p>
						Next, update the UI by adding a new header element:
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>4. Updated virtual DOM creation</h4>
					<p>
						In this step, React creates an updated virtual DOM that includes the new header element.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const updatedVirtualDOM = {
							type: 'div',
							props: {},
							children: [
								{
									type: 'h1',
									props: {},
									children: ['Hello'],
								},
								{
									type: 'h2',
									props: {},
									children: ['React'],
								},
								{
									type: 'h3',
									props: {},
									children: ['Element'],
								},
							],
						};
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>5. Diffing the virtual DOMs</h4>
					<p>
						React now compares the initial and updated virtual DOMs to identify what has changed. React uses it's diffing algorithm
						to determine the differences between the two virtual DOMs by:
					</p>
					<ul>
						<li>Comparing each node in the initial and updated virtual DOMs.</li>
						<li>Identify any additions, deletions, or modifications.</li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>6. Identifying changes</h4>
					<p>
						After diffing, React determines the specific changes needed. It reviews the findings of the diffing process to see what
						updates are necessary.
					</p>
					<ul>
						<li>Unchanged nodes: <code>&lt;h1&gt;Hello&lt;/h1&gt;</code> and <code>&lt;h2&gt;React&lt;/h2&gt;</code></li>
						<li>New node detected: <code>&lt;h3&gt;Element&lt;/h3&gt;</code></li>
					</ul>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<h4>7. Updating the real DOM</h4>
					<p>
						React updates the real DOM by applying changes identified during the diffing process, inserting the new element (<code>&lt;h3&gt;Element&lt;/h3&gt;</code>) into the real DOM under the existing <code>&lt;div&gt;</code> element.
					</p>
					<pre><code class="html" style="word-wrap: break-word;" data-trim>
						<div>
							<h1>Hello</h1>
							<h2>React</h2>
							<h3>Element</h3>
						</div>
					</code></pre>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<p>
						<img src="./img/Browser-DOM-Virtual-DOM.webp">
					</p>
					<small>Source: <a
							href="https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/">https://www.geeksforgeeks.org/reactjs/reactjs-virtual-dom/</a></small>
				</section>
				<section>
					<h3>JSX (JavaScript XML)</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic. It's an optional syntax extension for JavaScript that looks like
						HTML but is compiled into JavaScript. It allows us to write UI code in a way that’s intuitive and closer to how our UI
						will look in the browser.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = <h1>Hello, JSX!</h1>;
					</code></pre>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const element = React.createElement('h1', null, 'Hello, JSX!');
					</code></pre>
				</section>
				<section>
					<h3>Rendering lists in JSX</h3>
					<p>
						React solves this problem with JSX, a syntax that lets us describe the structure of our UI in a concise, HTML-like
						format while seamlessly integrating JavaScript logic.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						const items = ['React', 'JSX', 'Components'];
						const elements = (
						<ul>
							{items.map((item) => (
							<li key={item}>{item}</li>
							))}
						</ul>
						);
						
						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(elements);
					</code></pre>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						The <code>createRoot</code> method takes one argument: <strong>Where to render</strong> - A DOM node in the HTML document where the React content will be displayed.
					</p>
					<p>
						Once the root container is created, the <code>render</code> method takes: <strong>What to render</strong> - A React element or JSX expression that describes the UI.
					</p>
					<p>
						Typically, React applications render their content inside a single HTML container, often an element with the ID <code>root</code>.
					</p>
				</section>
				<section>
					<h3><code>createRoot</code></h3>
					<p>
						Even though React components are the preferred way to handle dynamic updates, we can manually call the <code>render</code> method
						multiple times to update content. Each call replaces content in the DOM node.
					</p>
					<pre><code class="js" style="word-wrap: break-word;" data-trim>
						let counter = 0;
						const root = ReactDOM.createRoot(document.getElementById('root'));

						function updateCounter() {
							root.render(<h1>Counter: {counter}</h1>);
						}

						// Initial render
						updateCounter();

						// Simulate updates
						setInterval(() => {
							counter++;
							updateCounter();
						}, 500);
					</code></pre>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
